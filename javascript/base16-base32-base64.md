> 来自 掘金技术文章 https://juejin.im/post/5c0a2407f265da611f0780c7

> 我个人感觉base编码 本质就是把高位的值(相对的code编码也比较长或者值比较大 比如说中文unicode过万的code值 转换成二进制编码是四个字节),用低位表现出来 限定较低位的码值来表现
> base16 就是16个码值(0-9, A-F) base32 32个码值 base64 64个码值

### 编码流程

- 1. ILU 对应ascii 73, 76, 85
- 2. 二进制转换 1 = 0000 00001   73 = 0100 1001 ...
- 3. base16规则4个bit作为一个下标 也就是一个数值  一个单位  76 = 0100 1001 = 4 9  ILU = 494C55(base16编码后的结果)
- 4. 解码  就反过来
- 5. 如果自定义码值集合
  - base16码值范围 0000 - 1111  = 0 - 15 = 0 - F
  - base32码值范围 00000 - 11111 = 0 - 31 = 如下
  - base64码值范围 000000 - 111111 = 0 - 65

```
// 自定义base32字符集  各个位置和码值一一对应关系
var encoding = base32.NewEncoding("ybndrfg8ejkmcpqxot1uwisza345h769")  A-F 2 - 7

```

### 归类

| 名称    | 下标数字的位个数 | 编码表字符串 | 位数不足是否会不全 = | 编码后 数据量变化 |
| :-----:| :-------------:| :---------- | :-----------------| :---------------|
| base16 | 4 | 数字0~9 和 字母 A~F | 不会，位数刚好是 4 的倍数 | 由一个8位表示一个字符 变成 4位表示一个字符，数据量变 2 倍 |
| base32 | 5 | 大写字母A~Z 和 数字2~7 | 会 | 变为 8/5 倍 |
| base64 | 6 | 大写字母A~Z，小写字母a~z，数字0~9以及"+"，"/" | 会 | 变为 8/6=4/3 倍 |


### 总结

- 1. 一个字符所对应表格中的下标的 bit 位是多少个
- 2. 对应的编码表格是多少
