
<!DOCTYPE HTML>
<html lang="" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>compiler-parser-index · mpx文档</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        <meta name="author" content="滴滴出行webapp团队">
        
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="compiler-directives-bind.html" />
    
    
    <link rel="prev" href="compiler-helpers.html" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="../how-to-use-jira.html">
            
                <a href="../how-to-use-jira.html">
            
                    
                    关于jira使用记录
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3" >
            
                <span>
            
                    
                    javascript杂记
            
                </span>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.3.1" data-path="../javascript/apply-call-bind.html">
            
                <a href="../javascript/apply-call-bind.html">
            
                    
                    apply&call&bind解析
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.3.2" data-path="../javascript/base16-base32-base64.html">
            
                <a href="../javascript/base16-base32-base64.html">
            
                    
                    base16&base32&base64
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    
        <li class="chapter " data-level="1.4" data-path="readme.html">
            
                <a href="readme.html">
            
                    
                    vue-release2.6.9
            
                </a>
            

            
            <ul class="articles">
                
    
        <li class="chapter " data-level="1.4.1" data-path="compiler-helpers.html">
            
                <a href="compiler-helpers.html">
            
                    
                    compiler-helpers
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.4.2" data-path="compiler-parser-index.html">
            
                <a href="compiler-parser-index.html">
            
                    
                    compiler-parser-index
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.3" data-path="compiler-directives-bind.html">
            
                <a href="compiler-directives-bind.html">
            
                    
                    compiler-directives-bind
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.4" data-path="compiler-directives-index.html">
            
                <a href="compiler-directives-index.html">
            
                    
                    compiler-directives-index
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.5" data-path="compiler-directives-model.html">
            
                <a href="compiler-directives-model.html">
            
                    
                    compiler-directives-model
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.6" data-path="compiler-directives-on.html">
            
                <a href="compiler-directives-on.html">
            
                    
                    compiler-directives-on
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.7" data-path="shared-util.html">
            
                <a href="shared-util.html">
            
                    
                    shared-util
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.4.8" data-path="shared-constants.html">
            
                <a href="shared-constants.html">
            
                    
                    shared-constants
            
                </a>
            

            
        </li>
    

            </ul>
            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >compiler-parser-index</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="parser">parser</h1>
<pre><code class="lang-javascript"><span class="hljs-keyword">import</span> he <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;he&apos;</span>
<span class="hljs-keyword">import</span> { parseHTML } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./html-parser&apos;</span>
<span class="hljs-keyword">import</span> { parseText } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./text-parser&apos;</span>
<span class="hljs-keyword">import</span> { parseFilters } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;./filter-parser&apos;</span>
<span class="hljs-keyword">import</span> { genAssignmentCode } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../directives/model&apos;</span>
<span class="hljs-keyword">import</span> { extend, cached, no, camelize, hyphenate } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;shared/util&apos;</span>
<span class="hljs-keyword">import</span> { isIE, isEdge, isServerRendering } <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;core/util/env&apos;</span>

<span class="hljs-keyword">import</span> {
  addProp,
  addAttr,
  baseWarn,
  addHandler,
  addDirective,
  getBindingAttr,
  getAndRemoveAttr,
  getRawBindingAttr,
  pluckModuleFunction,
  getAndRemoveAttrByRegex
} <span class="hljs-keyword">from</span> <span class="hljs-string">&apos;../helpers&apos;</span>

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> onRE = <span class="hljs-regexp">/^@|^v-on:/</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> dirRE = process.env.VBIND_PROP_SHORTHAND  <span class="hljs-comment">// pdd: &#x5982;&#x679C;&#x4E3A;true &#x5219;&#x7C7B;&#x4F3C;.stop&#x4E5F;&#x662F;&#x5408;&#x6CD5;&#x7684;&#x6307;&#x4EE4;</span>
  ? <span class="hljs-regexp">/^v-|^@|^:|^\./</span>
  : <span class="hljs-regexp">/^v-|^@|^:/</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> forAliasRE = <span class="hljs-regexp">/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> forIteratorRE = <span class="hljs-regexp">/,([^,\}\]]*)(?:,([^,\}\]]*))?$/</span>
<span class="hljs-keyword">const</span> stripParensRE = <span class="hljs-regexp">/^\(|\)$/g</span>
<span class="hljs-keyword">const</span> dynamicArgRE = <span class="hljs-regexp">/^\[.*\]$/</span>

<span class="hljs-keyword">const</span> argRE = <span class="hljs-regexp">/:(.*)$/</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> bindRE = <span class="hljs-regexp">/^:|^\.|^v-bind:/</span>
<span class="hljs-keyword">const</span> propBindRE = <span class="hljs-regexp">/^\./</span>
<span class="hljs-keyword">const</span> modifierRE = <span class="hljs-regexp">/\.[^.\]]+(?=[^\]]*$)/g</span>

<span class="hljs-keyword">const</span> slotRE = <span class="hljs-regexp">/^v-slot(:|$)|^#/</span>

<span class="hljs-keyword">const</span> lineBreakRE = <span class="hljs-regexp">/[\r\n]/</span>
<span class="hljs-keyword">const</span> whitespaceRE = <span class="hljs-regexp">/\s+/g</span>

<span class="hljs-keyword">const</span> invalidAttributeRE = <span class="hljs-regexp">/[\s&quot;&apos;&lt;&gt;\/=]/</span>

<span class="hljs-keyword">const</span> decodeHTMLCached = cached(he.decode)

<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> emptySlotScopeToken = <span class="hljs-string">`_empty_`</span>

<span class="hljs-comment">// configurable state</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> warn: any
<span class="hljs-keyword">let</span> delimiters
<span class="hljs-keyword">let</span> transforms
<span class="hljs-keyword">let</span> preTransforms
<span class="hljs-keyword">let</span> postTransforms
<span class="hljs-keyword">let</span> platformIsPreTag
<span class="hljs-keyword">let</span> platformMustUseProp
<span class="hljs-keyword">let</span> platformGetTagNamespace
<span class="hljs-keyword">let</span> maybeComponent
</code></pre>
<h4 id="createastelement">createASTElement</h4>
<pre><code class="lang-javascript"><span class="hljs-comment">// pdd: &#x751F;&#x6210;AST&#x8282;&#x70B9;</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createASTElement</span> (<span class="hljs-params">
  tag: string,
  attrs: Array&lt;ASTAttr&gt;,
  parent: ASTElement | void
</span>): <span class="hljs-title">ASTElement</span> </span>{
  <span class="hljs-keyword">return</span> {
    type: <span class="hljs-number">1</span>,
    tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    rawAttrsMap: {},
    parent,
    children: []
  }
}
</code></pre>
<h4 id="parse">parse</h4>
<pre><code class="lang-javascript"><span class="hljs-comment">/**
 * Convert HTML string to AST.
 */</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parse</span> (<span class="hljs-params">
  template: string,
  options: CompilerOptions
</span>): <span class="hljs-title">ASTElement</span> | <span class="hljs-title">void</span> </span>{
  warn = options.warn || baseWarn

  <span class="hljs-comment">// &#x662F;&#x5426;&#x662F;&#x5728;pre&#x6807;&#x7B7E;&#x5185;</span>
  platformIsPreTag = options.isPreTag || no
  <span class="hljs-comment">// &#x7528;&#x6765;&#x68C0;&#x6D4B;&#x4E00;&#x4E2A;&#x5C5E;&#x6027;&#x5728;&#x6807;&#x7B7E;&#x4E2D;&#x662F;&#x5426;&#x8981;&#x4F7F;&#x7528;&#x5143;&#x7D20;&#x5BF9;&#x8C61;&#x539F;&#x751F;&#x7684; prop &#x8FDB;&#x884C;&#x7ED1;&#x5B9A;  &#x539F;&#x751F;&#x5C5E;&#x6027;&#x5982;&#x679C;&#x6709;&#x7684;&#x8BDD;  &#x5C31;&#x7528;&#x539F;&#x751F;&#x7684;&#x7ED1;&#x5B9A;</span>
  platformMustUseProp = options.mustUseProp || no
  <span class="hljs-comment">// &#x5143;&#x7D20;&#x547D;&#x540D;&#x7A7A;&#x95F4;</span>
  platformGetTagNamespace = options.getTagNamespace || no
  <span class="hljs-keyword">const</span> isReservedTag = options.isReservedTag || no
  maybeComponent = (el: ASTElement) =&gt; !!el.component || !isReservedTag(el.tag)

  transforms = pluckModuleFunction(options.modules, <span class="hljs-string">&apos;transformNode&apos;</span>)
  preTransforms = pluckModuleFunction(options.modules, <span class="hljs-string">&apos;preTransformNode&apos;</span>)
  postTransforms = pluckModuleFunction(options.modules, <span class="hljs-string">&apos;postTransformNode&apos;</span>)

  delimiters = options.delimiters

  <span class="hljs-keyword">const</span> stack = []
  <span class="hljs-keyword">const</span> preserveWhitespace = options.preserveWhitespace !== <span class="hljs-literal">false</span>
  <span class="hljs-keyword">const</span> whitespaceOption = options.whitespace
  <span class="hljs-keyword">let</span> root
  <span class="hljs-keyword">let</span> currentParent
  <span class="hljs-keyword">let</span> inVPre = <span class="hljs-literal">false</span>
  <span class="hljs-keyword">let</span> inPre = <span class="hljs-literal">false</span>
  <span class="hljs-keyword">let</span> warned = <span class="hljs-literal">false</span>

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">warnOnce</span> (<span class="hljs-params">msg, range</span>) </span>{
    <span class="hljs-keyword">if</span> (!warned) {
      warned = <span class="hljs-literal">true</span>
      warn(msg, range)
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">closeElement</span> (<span class="hljs-params">element</span>) </span>{
    trimEndingWhitespace(element)
    <span class="hljs-keyword">if</span> (!inVPre &amp;&amp; !element.processed) {
      element = processElement(element, options)
    }
    <span class="hljs-comment">// tree management</span>
    <span class="hljs-keyword">if</span> (!stack.length &amp;&amp; element !== root) {
      <span class="hljs-comment">// allow root elements with v-if, v-else-if and v-else</span>
      <span class="hljs-keyword">if</span> (root.if &amp;&amp; (element.elseif || element.else)) {
        <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span>) {
          checkRootConstraints(element)
        }
        addIfCondition(root, {
          exp: element.elseif,
          block: element
        })
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span>) {
        warnOnce(
          <span class="hljs-string">`Component template should contain exactly one root element. `</span> +
          <span class="hljs-string">`If you are using v-if on multiple elements, `</span> +
          <span class="hljs-string">`use v-else-if to chain them instead.`</span>,
          { start: element.start }
        )
      }
    }
    <span class="hljs-keyword">if</span> (currentParent &amp;&amp; !element.forbidden) {
      <span class="hljs-keyword">if</span> (element.elseif || element.else) {
        processIfConditions(element, currentParent)
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">if</span> (element.slotScope) {
          <span class="hljs-comment">// scoped slot</span>
          <span class="hljs-comment">// keep it in the children list so that v-else(-if) conditions can</span>
          <span class="hljs-comment">// find it as the prev node.</span>
          <span class="hljs-keyword">const</span> name = element.slotTarget || <span class="hljs-string">&apos;&quot;default&quot;&apos;</span>
          ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element
        }
        currentParent.children.push(element)
        element.parent = currentParent
      }
    }

    <span class="hljs-comment">// final children cleanup</span>
    <span class="hljs-comment">// filter out scoped slots</span>
    element.children = element.children.filter(c =&gt; !(c: any).slotScope)
    <span class="hljs-comment">// remove trailing whitespace node again</span>
    trimEndingWhitespace(element)

    <span class="hljs-comment">// check pre state</span>
    <span class="hljs-comment">// pdd: v-pre &#x4E0D;&#x5904;&#x7406;&#x53D8;&#x91CF;&#x884C;&#x4E3A;  &lt;span&gt;{{message}}&lt;/span&gt;  ===&gt; &#x8868;&#x73B0;&#x4E3A; &lt;span&gt;{{message}}&lt;/span&gt;  &#x4E0D;&#x505A;&#x7F16;&#x8BD1;</span>
    <span class="hljs-keyword">if</span> (element.pre) {
      inVPre = <span class="hljs-literal">false</span>
    }
    <span class="hljs-keyword">if</span> (platformIsPreTag(element.tag)) {
      inPre = <span class="hljs-literal">false</span>
    }
    <span class="hljs-comment">// apply post-transforms</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; postTransforms.length; i++) {
      postTransforms[i](element, options)
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">trimEndingWhitespace</span> (<span class="hljs-params">el</span>) </span>{
    <span class="hljs-comment">// remove trailing whitespace node</span>
    <span class="hljs-keyword">if</span> (!inPre) {
      <span class="hljs-keyword">let</span> lastNode
      <span class="hljs-keyword">while</span> (
        (lastNode = el.children[el.children.length - <span class="hljs-number">1</span>]) &amp;&amp;
        lastNode.type === <span class="hljs-number">3</span> &amp;&amp;
        lastNode.text === <span class="hljs-string">&apos; &apos;</span>
      ) {
        el.children.pop()
      }
    }
  }

  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkRootConstraints</span> (<span class="hljs-params">el</span>) </span>{
    <span class="hljs-keyword">if</span> (el.tag === <span class="hljs-string">&apos;slot&apos;</span> || el.tag === <span class="hljs-string">&apos;template&apos;</span>) {
      warnOnce(
        <span class="hljs-string">`Cannot use &lt;<span class="hljs-subst">${el.tag}</span>&gt; as component root element because it may `</span> +
        <span class="hljs-string">&apos;contain multiple nodes.&apos;</span>,
        { start: el.start }
      )
    }
    <span class="hljs-keyword">if</span> (el.attrsMap.hasOwnProperty(<span class="hljs-string">&apos;v-for&apos;</span>)) {
      warnOnce(
        <span class="hljs-string">&apos;Cannot use v-for on stateful component root element because &apos;</span> +
        <span class="hljs-string">&apos;it renders multiple elements.&apos;</span>,
        el.rawAttrsMap[<span class="hljs-string">&apos;v-for&apos;</span>]
      )
    }
  }

  parseHTML(template, {
    warn,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    outputSourceRange: options.outputSourceRange,
    start (tag, attrs, unary, start, end) {<span class="hljs-number">5</span>
      <span class="hljs-comment">// check namespace.</span>
      <span class="hljs-comment">// inherit parent ns if there is one</span>
      <span class="hljs-keyword">const</span> ns = (currentParent &amp;&amp; currentParent.ns) || platformGetTagNamespace(tag)

      <span class="hljs-comment">// handle IE svg bug</span>
      <span class="hljs-comment">/* istanbul ignore if */</span>
      <span class="hljs-comment">// &#x5904;&#x7406;IE&#x4E0B;&#x7684;svg&#x76F8;&#x5173;&#x5177;&#x4F53;&#x67E5;&#x770B; http://hcysun.me/vue-design/art/82vue-parsing.html</span>
      <span class="hljs-keyword">if</span> (isIE &amp;&amp; ns === <span class="hljs-string">&apos;svg&apos;</span>) {
        attrs = guardIESVGBug(attrs)
      }

      <span class="hljs-comment">// &#x653E;&#x7F6E;&#x4E86;attrsList</span>
      <span class="hljs-keyword">let</span> element: ASTElement = createASTElement(tag, attrs, currentParent)
      <span class="hljs-keyword">if</span> (ns) {
        element.ns = ns
      }

      <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span>) {
        <span class="hljs-keyword">if</span> (options.outputSourceRange) {
          element.start = start
          element.end = end
          element.rawAttrsMap = element.attrsList.reduce((cumulated, attr) =&gt; {
            cumulated[attr.name] = attr
            <span class="hljs-keyword">return</span> cumulated
          }, {})
        }
        attrs.forEach(attr =&gt; {
          <span class="hljs-keyword">if</span> (invalidAttributeRE.test(attr.name)) {
            warn(
              <span class="hljs-string">`Invalid dynamic argument expression: attribute names cannot contain `</span> +
              <span class="hljs-string">`spaces, quotes, &lt;, &gt;, / or =.`</span>,
              {
                start: attr.start + attr.name.indexOf(<span class="hljs-string">`[`</span>),
                end: attr.start + attr.name.length
              }
            )
          }
        })
      }

      <span class="hljs-keyword">if</span> (isForbiddenTag(element) &amp;&amp; !isServerRendering()) {
        element.forbidden = <span class="hljs-literal">true</span>
        process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span> &amp;&amp; warn(
          <span class="hljs-string">&apos;Templates should only be responsible for mapping the state to the &apos;</span> +
          <span class="hljs-string">&apos;UI. Avoid placing tags with side-effects in your templates, such as &apos;</span> +
          <span class="hljs-string">`&lt;<span class="hljs-subst">${tag}</span>&gt;`</span> + <span class="hljs-string">&apos;, as they will not be parsed.&apos;</span>,
          { start: element.start }
        )
      }

      <span class="hljs-comment">// apply pre-transforms</span>
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element
      }

      <span class="hljs-keyword">if</span> (!inVPre) {
        processPre(element)
        <span class="hljs-keyword">if</span> (element.pre) {
          inVPre = <span class="hljs-literal">true</span>
        }
      }
      <span class="hljs-keyword">if</span> (platformIsPreTag(element.tag)) {
        inPre = <span class="hljs-literal">true</span>
      }
      <span class="hljs-keyword">if</span> (inVPre) {
        processRawAttrs(element)
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!element.processed) {
        <span class="hljs-comment">// structural directives</span>
        processFor(element)
        processIf(element)
        processOnce(element)
      }

      <span class="hljs-keyword">if</span> (!root) {
        root = element
        <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span>) {
          checkRootConstraints(root)
        }
      }
      <span class="hljs-comment">// pdd: &#x5982;&#x679C;&#x4E0D;&#x662F;&#x95ED;&#x5408;&#x6807;&#x7B7E; &#x5F80;&#x5806;&#x6808;&#x91CC;&#x9762;push &#x5E76;&#x4E14;&#x7ED1;&#x5B9A;currentParent</span>
      <span class="hljs-keyword">if</span> (!unary) {
        currentParent = element
        stack.push(element)
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">// pdd: &#x5230;&#x7ED3;&#x5C3E;&#x7684;&#x65F6;&#x5019;&#x5904;&#x7406;&#x5BF9;&#x8C61;&#x7684;&#x5404;&#x79CD;&#x89E3;&#x6790; &#x8FD9;&#x8FB9;&#x5904;&#x7406;&#x7684;&#x662F;&#x81EA;&#x95ED;&#x5408;&#x6807;&#x7B7E;</span>
        closeElement(element)
      }
    },
    <span class="hljs-comment">// pdd: stack=[] &#x5B58;&#x50A8;&#x4E86;&#x6240;&#x6709;&#x7684;&#x7684;&#x975E;&#x95ED;&#x5408;&#x5143;&#x7D20;</span>
    <span class="hljs-comment">// pdd: &#x6BCF;&#x8C03;&#x7528;&#x4E00;&#x6B21;end &#x5904;&#x7406;&#x4E00;&#x4E2A;stack&#x4E2D;&#x6700;&#x540E;&#x65B0;&#x7684;&#x5143;&#x7D20; </span>
    end (tag, start, end) {
      <span class="hljs-keyword">const</span> element = stack[stack.length - <span class="hljs-number">1</span>]
      <span class="hljs-comment">// pop stack</span>
      stack.length -= <span class="hljs-number">1</span>
      currentParent = stack[stack.length - <span class="hljs-number">1</span>]
      <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span> &amp;&amp; options.outputSourceRange) {
        element.end = end
      }
      closeElement(element)
    },

    chars (text: string, start: number, end: number) {
      <span class="hljs-keyword">if</span> (!currentParent) {
        <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span>) {
          <span class="hljs-keyword">if</span> (text === template) {
            warnOnce(
              <span class="hljs-string">&apos;Component template requires a root element, rather than just text.&apos;</span>,
              { start }
            )
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((text = text.trim())) {
            warnOnce(
              <span class="hljs-string">`text &quot;<span class="hljs-subst">${text}</span>&quot; outside root element will be ignored.`</span>,
              { start }
            )
          }
        }
        <span class="hljs-keyword">return</span>
      }
      <span class="hljs-comment">// IE textarea placeholder bug</span>
      <span class="hljs-comment">/* istanbul ignore if */</span>
      <span class="hljs-keyword">if</span> (isIE &amp;&amp;
        currentParent.tag === <span class="hljs-string">&apos;textarea&apos;</span> &amp;&amp;
        currentParent.attrsMap.placeholder === text
      ) {
        <span class="hljs-keyword">return</span>
      }
      <span class="hljs-keyword">const</span> children = currentParent.children
      <span class="hljs-keyword">if</span> (inPre || text.trim()) {
        text = isTextTag(currentParent) ? text : decodeHTMLCached(text)
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!children.length) {
        <span class="hljs-comment">// remove the whitespace-only node right after an opening tag</span>
        text = <span class="hljs-string">&apos;&apos;</span>
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (whitespaceOption) {
        <span class="hljs-keyword">if</span> (whitespaceOption === <span class="hljs-string">&apos;condense&apos;</span>) {
          <span class="hljs-comment">// in condense mode, remove the whitespace node if it contains</span>
          <span class="hljs-comment">// line break, otherwise condense to a single space</span>
          text = lineBreakRE.test(text) ? <span class="hljs-string">&apos;&apos;</span> : <span class="hljs-string">&apos; &apos;</span>
        } <span class="hljs-keyword">else</span> {
          text = <span class="hljs-string">&apos; &apos;</span>
        }
      } <span class="hljs-keyword">else</span> {
        text = preserveWhitespace ? <span class="hljs-string">&apos; &apos;</span> : <span class="hljs-string">&apos;&apos;</span>
      }
      <span class="hljs-keyword">if</span> (text) {
        <span class="hljs-keyword">if</span> (!inPre &amp;&amp; whitespaceOption === <span class="hljs-string">&apos;condense&apos;</span>) {
          <span class="hljs-comment">// condense consecutive whitespaces into single space</span>
          text = text.replace(whitespaceRE, <span class="hljs-string">&apos; &apos;</span>)
        }
        <span class="hljs-keyword">let</span> res
        <span class="hljs-keyword">let</span> child: ?ASTNode
        <span class="hljs-keyword">if</span> (!inVPre &amp;&amp; text !== <span class="hljs-string">&apos; &apos;</span> &amp;&amp; (res = parseText(text, delimiters))) {
          child = {
            type: <span class="hljs-number">2</span>,
            expression: res.expression,
            tokens: res.tokens,
            text
          }
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (text !== <span class="hljs-string">&apos; &apos;</span> || !children.length || children[children.length - <span class="hljs-number">1</span>].text !== <span class="hljs-string">&apos; &apos;</span>) {
          child = {
            type: <span class="hljs-number">3</span>,
            text
          }
        }
        <span class="hljs-keyword">if</span> (child) {
          <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span> &amp;&amp; options.outputSourceRange) {
            child.start = start
            child.end = end
          }
          children.push(child)
        }
      }
    },
    comment (text: string, start, end) {
      <span class="hljs-comment">// adding anyting as a sibling to the root node is forbidden</span>
      <span class="hljs-comment">// comments should still be allowed, but ignored</span>
      <span class="hljs-keyword">if</span> (currentParent) {
        <span class="hljs-keyword">const</span> child: ASTText = {
          type: <span class="hljs-number">3</span>,
          text,
          isComment: <span class="hljs-literal">true</span>
        }
        <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span> &amp;&amp; options.outputSourceRange) {
          child.start = start
          child.end = end
        }
        currentParent.children.push(child)
      }
    }
  })
  <span class="hljs-keyword">return</span> root
}
</code></pre>
<h4 id="processpre">processPre</h4>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processPre</span> (<span class="hljs-params">el</span>) </span>{
  <span class="hljs-keyword">if</span> (getAndRemoveAttr(el, <span class="hljs-string">&apos;v-pre&apos;</span>) != <span class="hljs-literal">null</span>) {
    el.pre = <span class="hljs-literal">true</span>
  }
}
</code></pre>
<h4 id="processrawattrs">processRawAttrs</h4>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processRawAttrs</span> (<span class="hljs-params">el</span>) </span>{
  <span class="hljs-keyword">const</span> list = el.attrsList
  <span class="hljs-keyword">const</span> len = list.length
  <span class="hljs-keyword">if</span> (len) {
    <span class="hljs-keyword">const</span> attrs: <span class="hljs-built_in">Array</span>&lt;ASTAttr&gt; = el.attrs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len)
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) {
      attrs[i] = {
        name: list[i].name,
        value: <span class="hljs-built_in">JSON</span>.stringify(list[i].value)
      }
      <span class="hljs-keyword">if</span> (list[i].start != <span class="hljs-literal">null</span>) {
        attrs[i].start = list[i].start
        attrs[i].end = list[i].end
      }
    }
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!el.pre) {
    <span class="hljs-comment">// non root node in pre blocks with no attributes</span>
    el.plain = <span class="hljs-literal">true</span>
  }
}
</code></pre>
<h4 id="processelement">processElement</h4>
<pre><code class="lang-javascript"><span class="hljs-comment">// pdd: &#x89E3;&#x6790;&#x5F00;&#x59CB;</span>
<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processElement</span> (<span class="hljs-params">
  element: ASTElement,
  options: CompilerOptions
</span>) </span>{
  processKey(element)

  <span class="hljs-comment">// determine whether this is a plain element after</span>
  <span class="hljs-comment">// removing structural attributes</span>
  element.plain = (
    !element.key &amp;&amp;
    !element.scopedSlots &amp;&amp;
    !element.attrsList.length
  )

  processRef(element)
  processSlotContent(element)
  processSlotOutlet(element)
  processComponent(element)
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; transforms.length; i++) {
    element = transforms[i](element, options) || element
  }
  processAttrs(element)
  <span class="hljs-keyword">return</span> element
}
</code></pre>
<h4 id="processkey">processKey</h4>
<pre><code class="lang-javascript">
<span class="hljs-comment">// pdd: &#x89E3;&#x6790;key  &#x6700;&#x7EC8;&#x7ED3;&#x679C;&#x662F;el&#x4E0A;&#x6302;&#x8F7D;key&#x5C5E;&#x6027;</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processKey</span> (<span class="hljs-params">el</span>) </span>{
  <span class="hljs-keyword">const</span> exp = getBindingAttr(el, <span class="hljs-string">&apos;key&apos;</span>)
  <span class="hljs-keyword">if</span> (exp) {
    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span>) {
      <span class="hljs-keyword">if</span> (el.tag === <span class="hljs-string">&apos;template&apos;</span>) {
        warn(
          <span class="hljs-string">`&lt;template&gt; cannot be keyed. Place the key on real elements instead.`</span>,
          getRawBindingAttr(el, <span class="hljs-string">&apos;key&apos;</span>)
        )
      }
      <span class="hljs-keyword">if</span> (el.for) {
        <span class="hljs-keyword">const</span> iterator = el.iterator2 || el.iterator1
        <span class="hljs-keyword">const</span> parent = el.parent
        <span class="hljs-keyword">if</span> (iterator &amp;&amp; iterator === exp &amp;&amp; parent &amp;&amp; parent.tag === <span class="hljs-string">&apos;transition-group&apos;</span>) {
          warn(
            <span class="hljs-string">`Do not use v-for index as key on &lt;transition-group&gt; children, `</span> +
            <span class="hljs-string">`this is the same as not using keys.`</span>,
            getRawBindingAttr(el, <span class="hljs-string">&apos;key&apos;</span>),
            <span class="hljs-literal">true</span> <span class="hljs-comment">/* tip */</span>
          )
        }
      }
    }
    el.key = exp
  }
}
</code></pre>
<h4 id="processref">processRef</h4>
<pre><code class="lang-javascript"><span class="hljs-comment">// pdd: &#x76EE;&#x524D;&#x6765;&#x770B;&#x8FD9;&#x4E2A;process&#x53EA;&#x662F;&#x628A;ref&#x5B57;&#x7B26;&#x4E32;&#x83B7;&#x53D6;&#x5230;&#x4E86; </span>
<span class="hljs-comment">// pdd: &#x4F7F;&#x7528;&#x7684;&#x65F6;&#x5019;this.$refs&#x600E;&#x4E48;&#x653E;&#x8FDB;&#x53BB;&#x7684;&#x8FD8;&#x9700;&#x8981;&#x89C2;&#x5BDF;</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processRef</span> (<span class="hljs-params">el</span>) </span>{
  <span class="hljs-keyword">const</span> ref = getBindingAttr(el, <span class="hljs-string">&apos;ref&apos;</span>)
  <span class="hljs-keyword">if</span> (ref) {
    el.ref = ref
    el.refInFor = checkInFor(el) <span class="hljs-comment">// pdd: &#x662F;&#x5426;&#x5728;for&#x5FAA;&#x73AF;&#x4E2D;&#x7684;&#x6807;&#x8BB0;</span>
  }
}
</code></pre>
<h4 id="processfor">processFor</h4>
<pre><code class="lang-javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processFor</span> (<span class="hljs-params">el: ASTElement</span>) </span>{
  <span class="hljs-keyword">let</span> exp
  <span class="hljs-keyword">if</span> ((exp = getAndRemoveAttr(el, <span class="hljs-string">&apos;v-for&apos;</span>))) {
    <span class="hljs-keyword">const</span> res = parseFor(exp)
    <span class="hljs-keyword">if</span> (res) {
      extend(el, res)
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span>) {
      warn(
        <span class="hljs-string">`Invalid v-for expression: <span class="hljs-subst">${exp}</span>`</span>,
        el.rawAttrsMap[<span class="hljs-string">&apos;v-for&apos;</span>]
      )
    }
  }

}
</code></pre>
<h4 id="forparseresult">ForParseResult</h4>
<pre><code class="lang-javascript">
type ForParseResult = {
  <span class="hljs-keyword">for</span>: string;
  alias: string;
  iterator1?: string;
  iterator2?: string;
};
</code></pre>
<h4 id="parsefor">parseFor</h4>
<pre><code class="lang-javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseFor</span> (<span class="hljs-params">exp: string</span>): ?<span class="hljs-title">ForParseResult</span> </span>{
  <span class="hljs-keyword">const</span> inMatch = exp.match(forAliasRE)
  <span class="hljs-keyword">if</span> (!inMatch) <span class="hljs-keyword">return</span>
  <span class="hljs-keyword">const</span> res = {}
  res.for = inMatch[<span class="hljs-number">2</span>].trim()
  <span class="hljs-keyword">const</span> alias = inMatch[<span class="hljs-number">1</span>].trim().replace(stripParensRE, <span class="hljs-string">&apos;&apos;</span>)
  <span class="hljs-keyword">const</span> iteratorMatch = alias.match(forIteratorRE)
  <span class="hljs-keyword">if</span> (iteratorMatch) {
    res.alias = alias.replace(forIteratorRE, <span class="hljs-string">&apos;&apos;</span>).trim()
    res.iterator1 = iteratorMatch[<span class="hljs-number">1</span>].trim()
    <span class="hljs-keyword">if</span> (iteratorMatch[<span class="hljs-number">2</span>]) {
      res.iterator2 = iteratorMatch[<span class="hljs-number">2</span>].trim()
    }
  } <span class="hljs-keyword">else</span> {
    res.alias = alias
  }
  <span class="hljs-comment">// pdd: todos = [{}, {}]</span>
  <span class="hljs-comment">// pdd: v-for=&quot;(todo, index) in todos&quot;</span>
  <span class="hljs-comment">// pdd: &#x8FD4;&#x56DE;&#x7684;&#x6570;&#x636E;&#x683C;&#x5F0F;&#x4E3A;{ alias: &apos;todo&apos;, for: &apos;todos&apos;, iterator1: &apos;index&apos; }</span>

  <span class="hljs-comment">// pdd: &#x5F53;&#x904D;&#x5386;&#x4E00;&#x4E2A;&#x5BF9;&#x8C61;&#x7684;&#x65F6;&#x5019;&#x7684;&#x5904;&#x7406;</span>
  <span class="hljs-comment">// pdd: todos = {}</span>
  <span class="hljs-comment">// pdd: v-for=&quot;(todo, key, index) in todos&quot;</span>
  <span class="hljs-comment">// pdd: &#x8FD4;&#x56DE;&#x7684;&#x6570;&#x636E;&#x683C;&#x5F0F;&#x4E3A;{ alias: &apos;todo&apos;, for: &apos;todos&apos;, iterator1: &apos;key&apos;, iterator2: &apos;index&apos; } </span>
  <span class="hljs-keyword">return</span> res
}
</code></pre>
<h4 id="processif">processIf</h4>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processIf</span> (<span class="hljs-params">el</span>) </span>{
  <span class="hljs-keyword">const</span> exp = getAndRemoveAttr(el, <span class="hljs-string">&apos;v-if&apos;</span>)
  <span class="hljs-keyword">if</span> (exp) {
    el.if = exp
    addIfCondition(el, {
      exp: exp,
      block: el
    })
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">if</span> (getAndRemoveAttr(el, <span class="hljs-string">&apos;v-else&apos;</span>) != <span class="hljs-literal">null</span>) {
      el.else = <span class="hljs-literal">true</span>
    }
    <span class="hljs-keyword">const</span> elseif = getAndRemoveAttr(el, <span class="hljs-string">&apos;v-else-if&apos;</span>)
    <span class="hljs-keyword">if</span> (elseif) {
      el.elseif = elseif
    }
  }
}
</code></pre>
<h4 id="processifconditions">processIfConditions</h4>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processIfConditions</span> (<span class="hljs-params">el, parent</span>) </span>{
  <span class="hljs-keyword">const</span> prev = findPrevElement(parent.children)
  <span class="hljs-keyword">if</span> (prev &amp;&amp; prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    })
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span>) {
    warn(
      <span class="hljs-string">`v-<span class="hljs-subst">${el.elseif ? (&apos;else-if=&quot;&apos; + el.elseif + &apos;&quot;&apos;) : &apos;else&apos;}</span> `</span> +
      <span class="hljs-string">`used on element &lt;<span class="hljs-subst">${el.tag}</span>&gt; without corresponding v-if.`</span>,
      el.rawAttrsMap[el.elseif ? <span class="hljs-string">&apos;v-else-if&apos;</span> : <span class="hljs-string">&apos;v-else&apos;</span>]
    )
  }
}
</code></pre>
<h4 id="findprevelement">findPrevElement</h4>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">findPrevElement</span> (<span class="hljs-params">children: Array&lt;any&gt;</span>): <span class="hljs-title">ASTElement</span> | <span class="hljs-title">void</span> </span>{
  <span class="hljs-keyword">let</span> i = children.length
  <span class="hljs-keyword">while</span> (i--) {
    <span class="hljs-keyword">if</span> (children[i].type === <span class="hljs-number">1</span>) {
      <span class="hljs-keyword">return</span> children[i]
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span> &amp;&amp; children[i].text !== <span class="hljs-string">&apos; &apos;</span>) {
        warn(
          <span class="hljs-string">`text &quot;<span class="hljs-subst">${children[i].text.trim()}</span>&quot; between v-if and v-else(-if) `</span> +
          <span class="hljs-string">`will be ignored.`</span>,
          children[i]
        )
      }
      children.pop()
    }
  }
}
</code></pre>
<h4 id="addifcondition">addIfCondition</h4>
<pre><code class="lang-javascript"><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addIfCondition</span> (<span class="hljs-params">el: ASTElement, condition: ASTIfCondition</span>) </span>{
  <span class="hljs-keyword">if</span> (!el.ifConditions) {
    el.ifConditions = []
  }
  el.ifConditions.push(condition)
}
</code></pre>
<h4 id="processonce">processOnce</h4>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processOnce</span> (<span class="hljs-params">el</span>) </span>{
  <span class="hljs-keyword">const</span> once = getAndRemoveAttr(el, <span class="hljs-string">&apos;v-once&apos;</span>)
  <span class="hljs-keyword">if</span> (once != <span class="hljs-literal">null</span>) {
    el.once = <span class="hljs-literal">true</span>
  }
}
</code></pre>
<h4 id="processslotcontent">processSlotContent</h4>
<pre><code class="lang-javascript">
<span class="hljs-comment">// pdd: el.slotScope&#x83B7;&#x53D6;scope&#x7684;&#x5B57;&#x6BB5;&#x540D;&#x79F0;&#x800C;&#x5DF2;</span>
<span class="hljs-comment">// handle content being passed to a component as slot,</span>
<span class="hljs-comment">// e.g. &lt;template slot=&quot;xxx&quot;&gt;, &lt;div slot-scope=&quot;xxx&quot;&gt;</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processSlotContent</span> (<span class="hljs-params">el</span>) </span>{
  <span class="hljs-keyword">let</span> slotScope
  <span class="hljs-keyword">if</span> (el.tag === <span class="hljs-string">&apos;template&apos;</span>) {
    slotScope = getAndRemoveAttr(el, <span class="hljs-string">&apos;scope&apos;</span>)
    <span class="hljs-comment">/* istanbul ignore if */</span>
    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span> &amp;&amp; slotScope) {
      warn(
        <span class="hljs-string">`the &quot;scope&quot; attribute for scoped slots have been deprecated and `</span> +
        <span class="hljs-string">`replaced by &quot;slot-scope&quot; since 2.5. The new &quot;slot-scope&quot; attribute `</span> +
        <span class="hljs-string">`can also be used on plain elements in addition to &lt;template&gt; to `</span> +
        <span class="hljs-string">`denote scoped slots.`</span>,
        el.rawAttrsMap[<span class="hljs-string">&apos;scope&apos;</span>],
        <span class="hljs-literal">true</span>
      )
    }
    el.slotScope = slotScope || getAndRemoveAttr(el, <span class="hljs-string">&apos;slot-scope&apos;</span>)
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((slotScope = getAndRemoveAttr(el, <span class="hljs-string">&apos;slot-scope&apos;</span>))) {
    <span class="hljs-comment">/* istanbul ignore if */</span>
    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span> &amp;&amp; el.attrsMap[<span class="hljs-string">&apos;v-for&apos;</span>]) {
      warn(
        <span class="hljs-string">`Ambiguous combined usage of slot-scope and v-for on &lt;<span class="hljs-subst">${el.tag}</span>&gt; `</span> +
        <span class="hljs-string">`(v-for takes higher priority). Use a wrapper &lt;template&gt; for the `</span> +
        <span class="hljs-string">`scoped slot to make it clearer.`</span>,
        el.rawAttrsMap[<span class="hljs-string">&apos;slot-scope&apos;</span>],
        <span class="hljs-literal">true</span>
      )
    }
    el.slotScope = slotScope
  }

  <span class="hljs-comment">// slot=&quot;xxx&quot;</span>
  <span class="hljs-keyword">const</span> slotTarget = getBindingAttr(el, <span class="hljs-string">&apos;slot&apos;</span>)
  <span class="hljs-keyword">if</span> (slotTarget) {
    el.slotTarget = slotTarget === <span class="hljs-string">&apos;&quot;&quot;&apos;</span> ? <span class="hljs-string">&apos;&quot;default&quot;&apos;</span> : slotTarget
    el.slotTargetDynamic = !!(el.attrsMap[<span class="hljs-string">&apos;:slot&apos;</span>] || el.attrsMap[<span class="hljs-string">&apos;v-bind:slot&apos;</span>])
    <span class="hljs-comment">// preserve slot as an attribute for native shadow DOM compat</span>
    <span class="hljs-comment">// only for non-scoped slots.</span>
    <span class="hljs-keyword">if</span> (el.tag !== <span class="hljs-string">&apos;template&apos;</span> &amp;&amp; !el.slotScope) {
      addAttr(el, <span class="hljs-string">&apos;slot&apos;</span>, slotTarget, getRawBindingAttr(el, <span class="hljs-string">&apos;slot&apos;</span>))
    }
  }

  <span class="hljs-comment">// 2.6 v-slot syntax</span>
  <span class="hljs-keyword">if</span> (process.env.NEW_SLOT_SYNTAX) {
    <span class="hljs-keyword">if</span> (el.tag === <span class="hljs-string">&apos;template&apos;</span>) {
      <span class="hljs-comment">// v-slot on &lt;template&gt;</span>
      <span class="hljs-keyword">const</span> slotBinding = getAndRemoveAttrByRegex(el, slotRE)
      <span class="hljs-keyword">if</span> (slotBinding) {
        <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span>) {
          <span class="hljs-keyword">if</span> (el.slotTarget || el.slotScope) {
            warn(
              <span class="hljs-string">`Unexpected mixed usage of different slot syntaxes.`</span>,
              el
            )
          }
          <span class="hljs-keyword">if</span> (el.parent &amp;&amp; !maybeComponent(el.parent)) {
            warn(
              <span class="hljs-string">`&lt;template v-slot&gt; can only appear at the root level inside `</span> +
              <span class="hljs-string">`the receiving the component`</span>,
              el
            )
          }
        }
        <span class="hljs-keyword">const</span> { name, dynamic } = getSlotName(slotBinding)
        el.slotTarget = name
        el.slotTargetDynamic = dynamic
        el.slotScope = slotBinding.value || emptySlotScopeToken <span class="hljs-comment">// force it into a scoped slot for perf</span>
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// v-slot on component, denotes default slot</span>
      <span class="hljs-keyword">const</span> slotBinding = getAndRemoveAttrByRegex(el, slotRE)
      <span class="hljs-keyword">if</span> (slotBinding) {
        <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span>) {
          <span class="hljs-keyword">if</span> (!maybeComponent(el)) {
            warn(
              <span class="hljs-string">`v-slot can only be used on components or &lt;template&gt;.`</span>,
              slotBinding
            )
          }
          <span class="hljs-keyword">if</span> (el.slotScope || el.slotTarget) {
            warn(
              <span class="hljs-string">`Unexpected mixed usage of different slot syntaxes.`</span>,
              el
            )
          }
          <span class="hljs-keyword">if</span> (el.scopedSlots) {
            warn(
              <span class="hljs-string">`To avoid scope ambiguity, the default slot should also use `</span> +
              <span class="hljs-string">`&lt;template&gt; syntax when there are other named slots.`</span>,
              slotBinding
            )
          }
        }
        <span class="hljs-comment">// add the component&apos;s children to its default slot</span>
        <span class="hljs-keyword">const</span> slots = el.scopedSlots || (el.scopedSlots = {})
        <span class="hljs-keyword">const</span> { name, dynamic } = getSlotName(slotBinding)
        <span class="hljs-keyword">const</span> slotContainer = slots[name] = createASTElement(<span class="hljs-string">&apos;template&apos;</span>, [], el)
        slotContainer.slotTarget = name
        slotContainer.slotTargetDynamic = dynamic
        slotContainer.children = el.children.filter((c: any) =&gt; {
          <span class="hljs-keyword">if</span> (!c.slotScope) {
            c.parent = slotContainer
            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
          }
        })
        slotContainer.slotScope = slotBinding.value || emptySlotScopeToken
        <span class="hljs-comment">// remove children as they are returned from scopedSlots now</span>
        el.children = []
        <span class="hljs-comment">// mark el non-plain so data gets generated</span>
        el.plain = <span class="hljs-literal">false</span>
      }
    }
  }
}
</code></pre>
<h4 id="getslotname">getSlotName</h4>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSlotName</span> (<span class="hljs-params">binding</span>) </span>{
  <span class="hljs-keyword">let</span> name = binding.name.replace(slotRE, <span class="hljs-string">&apos;&apos;</span>)
  <span class="hljs-keyword">if</span> (!name) {
    <span class="hljs-keyword">if</span> (binding.name[<span class="hljs-number">0</span>] !== <span class="hljs-string">&apos;#&apos;</span>) {
      name = <span class="hljs-string">&apos;default&apos;</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span>) {
      warn(
        <span class="hljs-string">`v-slot shorthand syntax requires a slot name.`</span>,
        binding
      )
    }
  }
  <span class="hljs-keyword">return</span> dynamicArgRE.test(name)
    <span class="hljs-comment">// dynamic [name]</span>
    ? { name: name.slice(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>), dynamic: <span class="hljs-literal">true</span> }
    <span class="hljs-comment">// static name</span>
    : { name: <span class="hljs-string">`&quot;<span class="hljs-subst">${name}</span>&quot;`</span>, dynamic: <span class="hljs-literal">false</span> }
}
</code></pre>
<h4 id="processslotoutlet">processSlotOutlet</h4>
<pre><code class="lang-javascript"><span class="hljs-comment">// pdd: slot&#x6807;&#x7B7E;&#x5904;&#x7406;  el.slotName&#x83B7;&#x53D6;</span>
<span class="hljs-comment">// handle &lt;slot/&gt; outlets</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processSlotOutlet</span> (<span class="hljs-params">el</span>) </span>{
  <span class="hljs-keyword">if</span> (el.tag === <span class="hljs-string">&apos;slot&apos;</span>) {
    el.slotName = getBindingAttr(el, <span class="hljs-string">&apos;name&apos;</span>)
    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span> &amp;&amp; el.key) {
      warn(
        <span class="hljs-string">`\`key\` does not work on &lt;slot&gt; because slots are abstract outlets `</span> +
        <span class="hljs-string">`and can possibly expand into multiple elements. `</span> +
        <span class="hljs-string">`Use the key on a wrapping element instead.`</span>,
        getRawBindingAttr(el, <span class="hljs-string">&apos;key&apos;</span>)
      )
    }
  }
}
</code></pre>
<h4 id="processcomponent">processComponent</h4>
<pre><code class="lang-javascript"><span class="hljs-comment">// pdd: &#x83B7;&#x53D6;is&#x5C5E;&#x6027; &lt;div :is=&quot;custom-component&quot;&gt;&lt;/div&gt;</span>
<span class="hljs-comment">// pdd: &#x83B7;&#x53D6;inline-template&#x5C5E;&#x6027; &lt;custom-component inline-template&gt;&lt;/custom-component&gt;</span>
<span class="hljs-comment">// pdd: inline-template&#x8868;&#x793A;&#x5F53;&#x505A;  &#x5F53;&#x505A;&#x6A21;&#x677F;&#x5904;&#x7406; </span>
<span class="hljs-comment">// pdd: &#x672C;&#x8D28;&#x4E0A;&#x662F;&#x4F5C;&#x4E3A;&#x4E00;&#x79CD;&#x5916;&#x90E8;&#x5B9A;&#x4E49;&#x6A21;&#x677F;&#x7684;&#x65B9;&#x5F0F; &#x4E0E;.vue&#x6587;&#x4EF6;&#x4E2D;&lt;template&gt;&#x6807;&#x7B7E;&#x5305;&#x88F9;&#x6548;&#x679C;&#x76F8;&#x540C; &#x800C;&#x4E14;&#x8FD8;&#x6709;&#x4E00;&#x4E2A;&#x7279;&#x6027; &#x5982;&#x679C;&#x7236;&#x5B50;&#x53D8;&#x91CF;&#x540D;&#x79F0;&#x76F8;&#x540C;  &#x4F18;&#x5148;&#x4F7F;&#x7528;&#x5B50;&#x7EC4;&#x4EF6;&#x7684;</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processComponent</span> (<span class="hljs-params">el</span>) </span>{
  <span class="hljs-keyword">let</span> binding
  <span class="hljs-keyword">if</span> ((binding = getBindingAttr(el, <span class="hljs-string">&apos;is&apos;</span>))) {
    el.component = binding
  }
  <span class="hljs-keyword">if</span> (getAndRemoveAttr(el, <span class="hljs-string">&apos;inline-template&apos;</span>) != <span class="hljs-literal">null</span>) {
    el.inlineTemplate = <span class="hljs-literal">true</span>
  }
}
</code></pre>
<h5 id="processattrs">processAttrs</h5>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">processAttrs</span> (<span class="hljs-params">el</span>) </span>{
  <span class="hljs-keyword">const</span> list = el.attrsList
  <span class="hljs-keyword">let</span> i, l, name, rawName, value, modifiers, syncGen, isDynamic
  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, l = list.length; i &lt; l; i++) {
    name = rawName = list[i].name
    value = list[i].value
    <span class="hljs-keyword">if</span> (dirRE.test(name)) {
      <span class="hljs-comment">// mark element as dynamic</span>
      el.hasBindings = <span class="hljs-literal">true</span>
      <span class="hljs-comment">// modifiers</span>
      <span class="hljs-comment">// pdd: &#x83B7;&#x53D6;&#x4FEE;&#x9970;&#x7B26;&#x96C6;&#x5408; &#x53EF;&#x4EE5;&#x6709;&#x591A;&#x4E2A;&#x4FEE;&#x9970;&#x7B26; v-on:event.stop.once.xxx</span>
      modifiers = parseModifiers(name.replace(dirRE, <span class="hljs-string">&apos;&apos;</span>))
      <span class="hljs-comment">// support .foo shorthand syntax for the .prop modifier</span>
      <span class="hljs-comment">// pdd: &#x4EE5;&#x4E0B;&#x64CD;&#x4F5C;&#x662F;&#x83B7;&#x53D6;&#x6307;&#x4EE4;&#x5C5E;&#x6027;&#x7684;&#x540D;&#x79F0;  &#x5982;&#x679C;&#x662F;&lt;div .foo=&quot;bar&quot;&gt;  &#x5219;&#x628A;.foo&#x89E3;&#x6790;&#x6210;&#x539F;&#x751F;&#x5C5E;&#x6027;  .foo  document.setAttribute(&apos;.foo&apos;, &apos;bar&apos;)</span>
      <span class="hljs-keyword">if</span> (process.env.VBIND_PROP_SHORTHAND &amp;&amp; propBindRE.test(name)) {
        (modifiers || (modifiers = {})).prop = <span class="hljs-literal">true</span>
        <span class="hljs-comment">// pdd: &#x5982;&#x679C;&#x662F;.foo.stop.xxx  &#x5219;&#x83B7;&#x53D6;foo.stop.xxx  replace =&gt; foo</span>
        <span class="hljs-comment">// pdd: name=.foo  &#x66FF;&#x6362;&#x6389;&#x4FEE;&#x9970;&#x7B26;</span>
        name = <span class="hljs-string">`.`</span> + name.slice(<span class="hljs-number">1</span>).replace(modifierRE, <span class="hljs-string">&apos;&apos;</span>)
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (modifiers) {
        <span class="hljs-comment">// pdd: &lt;div :foo=&quot;xx&quot;&gt;   name=&quot;foo&quot;  &#x66FF;&#x6362;&#x6389;&#x4FEE;&#x9970;&#x7B26;</span>
        name = name.replace(modifierRE, <span class="hljs-string">&apos;&apos;</span>)
      }
      <span class="hljs-keyword">if</span> (bindRE.test(name)) { <span class="hljs-comment">// v-bind</span>
        name = name.replace(bindRE, <span class="hljs-string">&apos;&apos;</span>)
        <span class="hljs-comment">// pdd: filter&#x6709;&#x53EF;&#x80FD;&#x51FA;&#x73B0;&#x5728;&#x5C5E;&#x6027;&#x7ED1;&#x5B9A;&#x4E2D; &#x6240;&#x4EE5;&#x8FC7;&#x4E00;&#x904D;parsefilters</span>
        <span class="hljs-comment">// pdd: &#x6240;&#x6709;&#x5C5E;&#x6027;attrs&#x90FD;&#x5F53;&#x6210;filter&#x7684;&#x4E00;&#x79CD;&#x5F62;&#x5F0F;&#x5904;&#x7406; &#x666E;&#x901A;attrs&#x7ED1;&#x5B9A;&#x5C31;&#x5F53;&#x6210;&#x662F;&#x6CA1;&#x6709;&#x7BA1;&#x9053;&#x64CD;&#x4F5C;&#x7B26;&#x7684;filter&#x6765;&#x5904;&#x7406;</span>
        value = parseFilters(value)
        isDynamic = dynamicArgRE.test(name)
        <span class="hljs-keyword">if</span> (isDynamic) {
          <span class="hljs-comment">// pdd: &#x5982;&#x679C;&#x662F;&#x52A8;&#x6001;&#x5C5E;&#x6027;  &#x5219;v-bind:[foo] &#x53D6;foo</span>
          name = name.slice(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)
        }
        <span class="hljs-keyword">if</span> (
          process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span> &amp;&amp;
          value.trim().length === <span class="hljs-number">0</span>
        ) {
          warn(
            <span class="hljs-string">`The value for a v-bind expression cannot be empty. Found in &quot;v-bind:<span class="hljs-subst">${name}</span>&quot;`</span>
          )
        }
        <span class="hljs-keyword">if</span> (modifiers) {
          <span class="hljs-comment">// pdd: .prop&#x4FEE;&#x9970;&#x7B26; &#x5904;&#x7406;&#x6210;&#x539F;&#x751F;&#x5C5E;&#x6027;  &#x4F1A;&#x901A;&#x8FC7;&#x8FD9;&#x79CD;&#x5F62;&#x5F0F;&#x5904;&#x7406;  document.setAttribute(&apos;xxx&apos;, xxx)</span>
          <span class="hljs-keyword">if</span> (modifiers.prop &amp;&amp; !isDynamic) {
            name = camelize(name)
            <span class="hljs-comment">// pdd: &#x666E;&#x901A;&#x7684;&#x5904;&#x7406; &#x76F4;&#x63A5;&#x9A7C;&#x5CF0;&#x5904;&#x7406;  innerHtml&#x6BD4;&#x8F83;&#x7279;&#x6B8A;</span>
            <span class="hljs-keyword">if</span> (name === <span class="hljs-string">&apos;innerHtml&apos;</span>) name = <span class="hljs-string">&apos;innerHTML&apos;</span>
          }
          <span class="hljs-comment">// pdd: camel   &lt;div  :user-data.camel=&quot;xxx&quot;&gt;&lt;/div&gt; ===&gt; userData</span>
          <span class="hljs-keyword">if</span> (modifiers.camel &amp;&amp; !isDynamic) {
            name = camelize(name)
          }
          <span class="hljs-comment">// pdd: sync&#x4FEE;&#x9970;&#x7B26;</span>
          <span class="hljs-keyword">if</span> (modifiers.sync) {
            syncGen = genAssignmentCode(value, <span class="hljs-string">`$event`</span>)
            <span class="hljs-keyword">if</span> (!isDynamic) {
              addHandler(
                el,
                <span class="hljs-string">`update:<span class="hljs-subst">${camelize(name)}</span>`</span>,
                syncGen,
                <span class="hljs-literal">null</span>,
                <span class="hljs-literal">false</span>,
                warn,
                list[i]
              )
              <span class="hljs-keyword">if</span> (hyphenate(name) !== camelize(name)) {
                addHandler(
                  el,
                  <span class="hljs-string">`update:<span class="hljs-subst">${hyphenate(name)}</span>`</span>,
                  syncGen,
                  <span class="hljs-literal">null</span>,
                  <span class="hljs-literal">false</span>,
                  warn,
                  list[i]
                )
              }
            } <span class="hljs-keyword">else</span> {
              <span class="hljs-comment">// handler w/ dynamic event name</span>
              addHandler(
                el,
                <span class="hljs-string">`&quot;update:&quot;+(<span class="hljs-subst">${name}</span>)`</span>,
                syncGen,
                <span class="hljs-literal">null</span>,
                <span class="hljs-literal">false</span>,
                warn,
                list[i],
                <span class="hljs-literal">true</span> <span class="hljs-comment">// dynamic</span>
              )
            }
          }
        }
        <span class="hljs-comment">// pdd: &#x5982;&#x679C;&#x6709;.prop&#x4FEE;&#x9970;&#x7B26;&#x4E14; .prop&#x4FEE;&#x9970;&#x7B26;&#x4E0D;&#x5E94;&#x7231;&#x88AB;props&#x89E3;&#x6790; &#x5E94;&#x8BE5;&#x7528;&#x4F5C;dom&#x7684;&#x5C5E;&#x6027;</span>
        <span class="hljs-comment">// pdd: &#x9664;&#x4E86;&#x7279;&#x6B8A;&#x6807;&#x7B7E;&#x548C;&#x7279;&#x6B8A;&#x503C;  value+input   selected+option &#x8FD9;&#x4E2A;&#x53EF;&#x4EE5;&#x88AB;&#x89E3;&#x6790;&#x6210;prop</span>
        <span class="hljs-comment">// pdd: &#x5426;&#x5219;&#x5F80;attra&#x6DFB;&#x52A0; &#x5F53;&#x6210;&#x666E;&#x901A;dom&#x5143;&#x7D20;&#x5904;&#x7406;</span>
        <span class="hljs-keyword">if</span> ((modifiers &amp;&amp; modifiers.prop) || (
          !el.component &amp;&amp; platformMustUseProp(el.tag, el.attrsMap.type, name)
        )) {
          <span class="hljs-comment">// pdd: props&#x4E0A;&#x6302;&#x5728;&#x5BF9;&#x8C61;&#x96C6;&#x5408;  el.props = [{}]</span>
          addProp(el, name, value, list[i], isDynamic)
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-comment">// pdd: attrs&#x4E0A;&#x6302;&#x5728;&#x5BF9;&#x8C61;&#x96C6;&#x5408;  el.attrs = [{}]</span>
          addAttr(el, name, value, list[i], isDynamic)
        }
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (onRE.test(name)) { <span class="hljs-comment">// v-on</span>
        name = name.replace(onRE, <span class="hljs-string">&apos;&apos;</span>)
        isDynamic = dynamicArgRE.test(name)
        <span class="hljs-keyword">if</span> (isDynamic) {
          name = name.slice(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)
        }
        addHandler(el, name, value, modifiers, <span class="hljs-literal">false</span>, warn, list[i], isDynamic)
      } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// normal directives</span>
        name = name.replace(dirRE, <span class="hljs-string">&apos;&apos;</span>)
        <span class="hljs-comment">// parse arg</span>
        <span class="hljs-keyword">const</span> argMatch = name.match(argRE)
        <span class="hljs-keyword">let</span> arg = argMatch &amp;&amp; argMatch[<span class="hljs-number">1</span>]
        isDynamic = <span class="hljs-literal">false</span>
        <span class="hljs-keyword">if</span> (arg) {
          name = name.slice(<span class="hljs-number">0</span>, -(arg.length + <span class="hljs-number">1</span>))
          <span class="hljs-keyword">if</span> (dynamicArgRE.test(arg)) {
            arg = arg.slice(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>)
            isDynamic = <span class="hljs-literal">true</span>
          }
        }
        <span class="hljs-comment">// pdd: &#x6307;&#x4EE4;&#x5904;&#x7406;</span>
        <span class="hljs-comment">// pdd: directives&#x4E0A;&#x6302;&#x5728;&#x5BF9;&#x8C61;&#x96C6;&#x5408;  el.directives = [{}]</span>
        addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i])
        <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span> &amp;&amp; name === <span class="hljs-string">&apos;model&apos;</span>) {
          checkForAliasModel(el, value)
        }
      }
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// literal attribute</span>
      <span class="hljs-comment">// pdd: src=&quot;{{}}&quot;  &#x6CA1;&#x6709;&#x5728;&#x4E0A;&#x8FF0;&#x5904;&#x7406;&#x4E2D;&#x5339;&#x914D;&#x7684;  &#x68C0;&#x67E5;&#x4E2D;&#x95F4;&#x662F;&#x5426;&#x6709;&#x63D2;&#x503C;&#x8868;&#x8FBE;&#x5F0F; &#x5982;&#x679C;&#x6709;&#x7ED9;&#x51FA;&#x63D0;&#x793A; &#x5DF2;&#x7ECF;&#x79FB;&#x9664;&#x8BE5;&#x529F;&#x80FD; &#x8BF7;&#x4F7F;&#x7528;v-bind&#x6307;&#x4EE4;&#x5B9E;&#x73B0;</span>
      <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span>) {
        <span class="hljs-keyword">const</span> res = parseText(value, delimiters)
        <span class="hljs-keyword">if</span> (res) {
          warn(
            <span class="hljs-string">`<span class="hljs-subst">${name}</span>=&quot;<span class="hljs-subst">${value}</span>&quot;: `</span> +
            <span class="hljs-string">&apos;Interpolation inside attributes has been removed. &apos;</span> +
            <span class="hljs-string">&apos;Use v-bind or the colon shorthand instead. For example, &apos;</span> +
            <span class="hljs-string">&apos;instead of &lt;div id=&quot;{{ val }}&quot;&gt;, use &lt;div :id=&quot;val&quot;&gt;.&apos;</span>,
            list[i]
          )
        }
      }
      <span class="hljs-comment">// pdd: JSON.stringify(value)&#x5904;&#x7406;&#x6587;&#x672C;&#x503C;</span>
      addAttr(el, name, <span class="hljs-built_in">JSON</span>.stringify(value), list[i])
      <span class="hljs-comment">// #6887 firefox doesn&apos;t update muted state if set via attribute</span>
      <span class="hljs-comment">// even immediately after element creation</span>
      <span class="hljs-comment">// pdd: &#x5355;&#x72EC;&#x5904;&#x7406;firefox video&#x6807;&#x7B7E;&#x4E0B;&#x7684;muted&#x5C5E;&#x6027;  &#x5177;&#x4F53;&#x6CA1;&#x6709;&#x8BD5;&#x9A8C;  &#x5E94;&#x8BE5;&#x662F;&#x8BF4;&#x9ED8;&#x8BA4;&#x64AD;&#x653E;&#x5668;&#x9759;&#x97F3;&#x64AD;&#x653E;&#x7684;&#x65F6;&#x5019;</span>
      <span class="hljs-comment">// pdd: muted=&quot;muted&quot; chrome&#x662F;&#x9759;&#x97F3;&#x64AD;&#x653E;&#x6548;&#x679C;  &#x4F46;&#x662F;&#x706B;&#x72D0;&#x4E0D;&#x884C;  &#x9700;&#x8981;&#x5F3A;&#x5236;&#x6307;&#x5B9A;muted=true</span>
      <span class="hljs-keyword">if</span> (!el.component &amp;&amp;
          name === <span class="hljs-string">&apos;muted&apos;</span> &amp;&amp;
          platformMustUseProp(el.tag, el.attrsMap.type, name)) {
        <span class="hljs-comment">// pdd: value=&quot;true&quot; &#x6267;&#x884C;&#x7684;&#x65F6;&#x5019; muted=true</span>
        addProp(el, name, <span class="hljs-string">&apos;true&apos;</span>, list[i])
      }
    }
  }
}
</code></pre>
<h4 id="checkinfor">checkInFor</h4>
<pre><code class="lang-javascript">
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkInFor</span> (<span class="hljs-params">el: ASTElement</span>): <span class="hljs-title">boolean</span> </span>{
  <span class="hljs-keyword">let</span> parent = el
  <span class="hljs-keyword">while</span> (parent) {
    <span class="hljs-keyword">if</span> (parent.for !== <span class="hljs-literal">undefined</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
    }
    parent = parent.parent
  }
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
}
</code></pre>
<h4 id="parsemodifiers">parseModifiers</h4>
<pre><code class="lang-javascript">
<span class="hljs-comment">// pdd: &#x89E3;&#x6790;&#x4FEE;&#x9970;&#x7B26;   v-bind:foo.stop.once.prevent=&quot;&quot; </span>
<span class="hljs-comment">// pdd: &#x53C2;&#x6570;name=&quot;.stop.once.prevent&quot;</span>
<span class="hljs-comment">// pdd: &#x89E3;&#x6790;&#x7ED3;&#x679C; { stop: true, once: true, prevent: true }</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseModifiers</span> (<span class="hljs-params">name: string</span>): <span class="hljs-title">Object</span> | <span class="hljs-title">void</span> </span>{
  <span class="hljs-keyword">const</span> match = name.match(modifierRE)
  <span class="hljs-keyword">if</span> (match) {
    <span class="hljs-keyword">const</span> ret = {}
    match.forEach(m =&gt; { ret[m.slice(<span class="hljs-number">1</span>)] = <span class="hljs-literal">true</span> })
    <span class="hljs-keyword">return</span> ret
  }
}
</code></pre>
<h4 id="makeattrsmap">makeAttrsMap</h4>
<pre><code class="lang-javascript">
<span class="hljs-comment">// pdd: &#x751F;&#x6210;&#x4E00;&#x4E2A;attrs map  &#x5C5E;&#x6027;key&#x4E3A;&#x952E;  &#x503C;&#x4E3A;value&#x7684;map {v-show: &apos;ifShow&apos;, key: &apos;id&apos;}</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">makeAttrsMap</span> (<span class="hljs-params">attrs: Array&lt;Object&gt;</span>): <span class="hljs-title">Object</span> </span>{
  <span class="hljs-keyword">const</span> map = {}
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = attrs.length; i &lt; l; i++) {
    <span class="hljs-keyword">if</span> (
      process.env.NODE_ENV !== <span class="hljs-string">&apos;production&apos;</span> &amp;&amp;
      map[attrs[i].name] &amp;&amp; !isIE &amp;&amp; !isEdge
    ) {
      warn(<span class="hljs-string">&apos;duplicate attribute: &apos;</span> + attrs[i].name, attrs[i])
    }
    map[attrs[i].name] = attrs[i].value
  }
  <span class="hljs-keyword">return</span> map
}
</code></pre>
<h4 id="istexttag">isTextTag</h4>
<pre><code class="lang-javascript"><span class="hljs-comment">// for script (e.g. type=&quot;x/template&quot;) or style, do not decode content</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isTextTag</span> (<span class="hljs-params">el</span>): <span class="hljs-title">boolean</span> </span>{
  <span class="hljs-keyword">return</span> el.tag === <span class="hljs-string">&apos;script&apos;</span> || el.tag === <span class="hljs-string">&apos;style&apos;</span>
}
</code></pre>
<h4 id="isforbiddentag">isForbiddenTag</h4>
<pre><code class="lang-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isForbiddenTag</span> (<span class="hljs-params">el</span>): <span class="hljs-title">boolean</span> </span>{
  <span class="hljs-keyword">return</span> (
    el.tag === <span class="hljs-string">&apos;style&apos;</span> ||
    (el.tag === <span class="hljs-string">&apos;script&apos;</span> &amp;&amp; (
      !el.attrsMap.type ||
      el.attrsMap.type === <span class="hljs-string">&apos;text/javascript&apos;</span>
    ))
  )
}
</code></pre>
<h4 id="guardiesvgbug">guardIESVGBug</h4>
<pre><code class="lang-javascript">
<span class="hljs-keyword">const</span> ieNSBug = <span class="hljs-regexp">/^xmlns:NS\d+/</span>
<span class="hljs-keyword">const</span> ieNSPrefix = <span class="hljs-regexp">/^NS\d+:/</span>

<span class="hljs-comment">/* istanbul ignore next */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">guardIESVGBug</span> (<span class="hljs-params">attrs</span>) </span>{
  <span class="hljs-keyword">const</span> res = []
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; attrs.length; i++) {
    <span class="hljs-keyword">const</span> attr = attrs[i]
    <span class="hljs-keyword">if</span> (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, <span class="hljs-string">&apos;&apos;</span>)
      res.push(attr)
    }
  }
  <span class="hljs-keyword">return</span> res
}
</code></pre>
<h4 id="checkforaliasmodel">checkForAliasModel</h4>
<pre><code class="lang-javascript"><span class="hljs-comment">// pdd: &#x68C0;&#x67E5;v-for&#x4E2D;&#x7684;v-model&#x60C5;&#x51B5; &#x5982;&#x679C;&lt;input v-for=&quot;item in list&quot; v-model=&quot;item&quot;/&gt;  &#x5982;&#x679C;list = [1, 2, 3] &#x5219;b-model&#x4F1A;&#x5931;&#x6548;</span>
<span class="hljs-comment">// pdd: &#x7ED9;&#x7528;&#x6237;&#x4E00;&#x4E2A;&#x63D0;&#x793A; &#x53EF;&#x4EE5;&#x6539;&#x4E3A;list = [{xx: 1}] v-model=&quot;item.xx&quot;</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkForAliasModel</span> (<span class="hljs-params">el, value</span>) </span>{
  <span class="hljs-keyword">let</span> _el = el
  <span class="hljs-keyword">while</span> (_el) {
    <span class="hljs-keyword">if</span> (_el.for &amp;&amp; _el.alias === value) {
      warn(
        <span class="hljs-string">`&lt;<span class="hljs-subst">${el.tag}</span> v-model=&quot;<span class="hljs-subst">${value}</span>&quot;&gt;: `</span> +
        <span class="hljs-string">`You are binding v-model directly to a v-for iteration alias. `</span> +
        <span class="hljs-string">`This will not be able to modify the v-for source array because `</span> +
        <span class="hljs-string">`writing to the alias is like modifying a function local variable. `</span> +
        <span class="hljs-string">`Consider using an array of objects and use v-model on an object property instead.`</span>,
        el.rawAttrsMap[<span class="hljs-string">&apos;v-model&apos;</span>]
      )
    }
    _el = _el.parent
  }
}
</code></pre>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="compiler-helpers.html" class="navigation navigation-prev " aria-label="Previous page: compiler-helpers">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="compiler-directives-bind.html" class="navigation navigation-next " aria-label="Next page: compiler-directives-bind">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"compiler-parser-index","level":"1.4.2","depth":2,"next":{"title":"compiler-directives-bind","level":"1.4.3","depth":2,"path":"vue-release2.6.9/compiler-directives-bind.md","ref":"vue-release2.6.9/compiler-directives-bind.md","articles":[]},"previous":{"title":"compiler-helpers","level":"1.4.1","depth":2,"path":"vue-release2.6.9/compiler-helpers.md","ref":"vue-release2.6.9/compiler-helpers.md","articles":[]},"dir":"ltr"},"config":{"plugins":[],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"github":{"url":"https://github.com/didi/mpx"},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"highlight":{},"favicon":"favicon.ico","github-buttons":{"buttons":[{"user":"didi","repo":"mpx","type":"star","size":"small","count":true},{"user":"didi","repo":"mpx","type":"fork","size":"small","count":true}]},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"edit-link":{"base":"https://github.com/didi/mpx/tree/master/docs","label":"完善文档"},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false},"insert-logo":{"url":"https://dpubstatic.udache.com/static/dpubimg/cd8de8e4-e4f4-4f0a-9c53-f833bc30ba69.png","style":"background: none; width: 200px"}},"theme":"default","author":"滴滴出行webapp团队","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"intro","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"mpx文档","gitbook":"*","description":"mpx是一款增强型小程序框架，极致性能优化，提供双向数据绑定，样式绑定，方法内联传参等方便开发者使用的特性。"},"file":{"path":"vue-release2.6.9/compiler-parser-index.md","mtime":"2019-08-07T06:37:51.870Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2019-08-07T07:15:29.501Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

